# Episode 02 - Igniting our app

Today, I separated the HTML, JS, and CSS files to maintain separation of concerns. I also created my own "create_react_app" to make my app production-ready.

To make my app production-ready, I needed to minify the code, optimize the app, bundle it, and run it on a server. I learned that React is a powerful tool, but it cannot do everything alone. That's why I use bundlers like Vite, Parcel, and Webpack to get the desired functionality.

In this project, I used Parcel as my bundler because it is zero-config and provides a lot of features for my app. To use Parcel in my app, I needed a package manager, and I chose npm. npm and yarn are the most commonly used package managers in the market, but I chose npm for this project.

## Installing npm and Parcel

To install npm in my app, I used the command `npm init` or `npm init -y` to skip all the questions. Once npm was installed, I saw a `package.json` file along with my existing files.

The `package.json` file contains metadata about my project, including the dependencies required for my app. I used this file to install external packages in my application.

To install Parcel in my app, I used the command `npm install -D parcel`. The `-D` flag installed the package as a dev dependency.

When I installed a package, I got a `package-lock.json` file in my app, which ensured that my app used the exact version of the package.

The caret (^) and tilde (~) signs in front of version numbers indicate which versions of a package are compatible with our app.

The `node_modules` file is like a database for npm. It contains all the packages and dependencies installed in our app. It's essential to put the `node_modules` file in the `.gitignore` folder to avoid uploading it to version control.

## Using React and React-DOM with npm

To install React and React-DOM, I used the command `npm install react react-dom`. I removed the CDN links that I used before and used these installed packages.

## Running the app with Parcel

To run my app, I used the command `npx parcel index.html`, which created a mini server to run my app on `localhost:1234`.

The `dist` folder contained the production-ready build of my app, and the `parcel_cache` folder contained cached files generated by Parcel during development.

I can make a production build using `npx parcel build index.html` and a development build using `npx parcel index.html`. It's essential to put the `dist` and `parcel_cache` folders in the `.gitignore` folder to avoid uploading them to version control.

## Using Browserlist to specify browser support

I also learned about Browserlist, which is a feature in package.json that allows me to specify which browsers I want to support for my project. By default, it uses a list of commonly used browsers and their versions. However, I can customize this list to better suit my needs. This is important because different browsers may have different capabilities and may require different features or polyfills to work properly. By specifying which browsers I want to support, I can ensure that my project will work correctly for my target audience.

Here's an example of how to specify a Browserlist in my package.json file:

```json
{
  "name": "my-project",
  "version": "1.0.0",
  "browserslist": ["last 2 versions", "not dead"],
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  }
}
```

In this example, I am specifying that I want to support the last two versions of all major browsers, except for any that are considered "dead" (i.e. no longer supported). I can customize the list to fit my specific needs by specifying different versions or browser names. The Browserslist documentation provides more information on how to use this feature.

## Parcel is a Beast:

Finally, I learned all the features of Parcel, including -

- HMR (Hot Module Replacement): Enables real-time changes to your code without needing to refresh the entire page, making development faster and more efficient.
- File watcher algorithm in C++: A performant file watcher that efficiently tracks changes to your code and rebuilds only what's necessary.
- Bundling: Combines all of your code and dependencies into a single file, making it easier to deploy and reducing page load times.
- Code minification: Reduces the size of your code by removing unnecessary whitespace and renaming variables, making it faster to download and execute.
- Image optimization: Automatically optimizes images to reduce their size without sacrificing quality, improving page load times.
- Caching: Speeds up development by caching assets and only rebuilding when necessary, improving build times.
- Compression: Reduces the size of your assets, making them faster to download and improving page load times.
- Tree shaking: Eliminates unused code from your final build, reducing its size and improving performance.
